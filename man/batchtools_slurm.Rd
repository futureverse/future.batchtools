% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/batchtools_slurm.R
\name{batchtools_slurm}
\alias{batchtools_slurm}
\title{A batchtools slurm backend resolves futures in parallel via a Slurm job scheduler}
\usage{
batchtools_slurm(
  ...,
  template = "slurm",
  scheduler.latency = 1,
  fs.latency = 65,
  resources = list(),
  delete = "on-success",
  workers = getOption("future.batchtools.workers", default = 100L)
)
}
\arguments{
\item{template}{(optional) Name of job-script template to be searched
for by \code{\link[batchtools:findTemplateFile]{batchtools::findTemplateFile()}}. If not found, it defaults to
the \code{templates/slurm.tmpl} part of this package (see below).}

\item{scheduler.latency}{[\code{numeric(1)}]\cr
Time to sleep after important interactions with the scheduler to ensure a sane state.
Currently only triggered after calling \code{\link[batchtools]{submitJobs}}.}

\item{fs.latency}{[\code{numeric(1)}]\cr
Expected maximum latency of the file system, in seconds.
Set to a positive number for network file systems like NFS which enables more robust (but also more expensive) mechanisms to
access files and directories.
Usually safe to set to \code{0} to disable the heuristic, e.g. if you are working on a local file system.}

\item{resources}{(optional) A named list passed to the \pkg{batchtools}
job-script template as variable \code{resources}.  See Section 'Resources'
in \code{\link[batchtools:submitJobs]{batchtools::submitJobs()}} more details.}

\item{delete}{Controls if and when the batchtools job registry folder is
deleted.
If \code{"on-success"} (default), it is deleted if the future was resolved
successfully \emph{and} the expression did not produce an error.
If \code{"never"}, then it is never deleted.
If \code{"always"}, then it is always deleted.}

\item{workers}{The maximum number of workers the batchtools backend may
use at any time, which for HPC schedulers corresponds to the maximum number
of queued jobs. The default is
\code{getOption("\link{future.batchtools.workers}", 100)}.}

\item{\ldots}{Not used.}
}
\description{
A batchtools slurm backend resolves futures in parallel via a Slurm job scheduler
}
\details{
Batchtools slurm futures use \pkg{batchtools} cluster functions
created by \code{\link[batchtools:makeClusterFunctionsSlurm]{batchtools::makeClusterFunctionsSlurm()}}, which requires
that Slurm commands \code{sbatch}, \code{squeue}, and \code{scancel} are installed on
the current machine.

The default template script \code{templates/slurm.tmpl} can be found in:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{system.file("templates", "slurm.tmpl", package = "future.batchtools")
}\if{html}{\out{</div>}}

and comprise:

\if{html}{\out{<div class="sourceCode bash">}}\preformatted{#!/bin/bash
######################################################################
# A batchtools launch script template for Slurm
#
# Author: Henrik Bengtsson 
######################################################################

## Job name
#SBATCH --job-name=<\%= job.name \%>
## Direct streams to logfile
#SBATCH --output=<\%= log.file \%>

## Resources needed:
<\%
  ## As-is resource specifications
  job_declarations <- resources[["asis"]]
  resources[["asis"]] <- NULL
     
  ## Environment modules specifications
  modules <- resources[["modules"]]
  resources[["modules"]] <- NULL
     
  ## Remaining resources are assumed to be of type '--<key>=<value>'
  opts <- unlist(resources, use.names = TRUE)
  opts <- sprintf("--\%s=\%s", names(opts), opts)
  job_declarations <- sprintf("#SBATCH \%s", c(job_declarations, opts))
  writeLines(job_declarations)
\%>

echo "Batchtools information:"
echo "- job name: '<\%= job.name \%>'"
echo "- job log file: '<\%= log.file \%>'"
echo

echo "Load environment modules:"
<\%
  writeLines(sprintf("module load \%s", modules))
\%>

echo "Session information:"
echo "- timestamp: $(date)"
echo "- hostname: $(hostname)"
echo "- Rscript path: $(which Rscript)"
echo "- Rscript version: $(Rscript --version)"
echo "- Rscript library paths: $(Rscript -e "cat(shQuote(.libPaths()), sep = ' ')")"
echo

echo "Job submission declarations:"
<\%
  writeLines(sprintf("echo '\%s'", job_declarations))
\%>

echo "Slurm job information:"
scontrol show job "$\{SLURM_JOB_ID\}"
echo

## Launch R and evaluate the batchtools R job
echo "Command: Rscript -e 'batchtools::doJobCollection("<\%= uri \%>")' ..."
Rscript -e 'batchtools::doJobCollection("<\%= uri \%>")'
res=$?
echo " - exit code: $\{res\}"
echo "Command: Rscript -e 'batchtools::doJobCollection("<\%= uri \%>")' ... done"

## End-of-job summary
sstat --format="JobID,AveCPU,MaxRSS,MaxPages,MaxDiskRead,MaxDiskWrite" --allsteps --jobs="$\{SLURM_JOB_ID\}"

## Relay the exit code from Rscript
exit "$\{res\}"
}\if{html}{\out{</div>}}

This template and the built-in \code{\link[batchtools:makeClusterFunctionsSlurm]{batchtools::makeClusterFunctionsSlurm()}}
have been verified to work with Slurm v21.08.4 running on a Rocky 8 Linux
cluster with an NFS global filesystem.
}
\examples{
\dontshow{if (interactive()) (if (getRversion() >= "3.4") withAutoprint else force)(\{ # examplesIf}
library(future)

# Limit runtime to 10 minutes and memory to 400 MiB per future,
# request a parallel environment with four slots on a single host.
# Submit to the 'freecycle' partition.
plan(future.batchtools::batchtools_slurm, resources = list(
  time = "00:10:00", mem = "400M",
  asis = c("--nodes=1", "--ntasks=4", "--partition=freecycle")
))

f <- future({
  data.frame(
    hostname = Sys.info()[["nodename"]],
          os = Sys.info()[["sysname"]],
       cores = unname(parallelly::availableCores()),
     modules = Sys.getenv("LOADEDMODULES")
  )
})
info <- value(f)
print(info)
\dontshow{\}) # examplesIf}
}
\references{
\itemize{
\item \url{https://en.wikipedia.org/wiki/Slurm_Workload_Manager}
}
}
